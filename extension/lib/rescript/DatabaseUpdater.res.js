// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Stdlib_Int from "@rescript/runtime/lib/es6/Stdlib_Int.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_JsExn from "@rescript/runtime/lib/es6/Stdlib_JsExn.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

let Response = {};

let Fetch = {
  Response: Response
};

function parseSafetyLevel(s) {
  switch (s) {
    case "dangerous" :
      return "dangerous";
    case "safe" :
      return "safe";
    default:
      return "experimental";
  }
}

function parseValueType(s) {
  switch (s) {
    case "float" :
      return "float";
    case "integer" :
      return "integer";
    case "string" :
      return "string";
    default:
      return "boolean";
  }
}

function parseCategory(s) {
  switch (s) {
    case "developer" :
      return "developer";
    case "network" :
      return "network";
    case "performance" :
      return "performance";
    case "privacy" :
      return "privacy";
    case "ui" :
      return "ui";
    default:
      return "experimental";
  }
}

function parsePermission(s) {
  switch (s) {
    case "browserSettings" :
      return "browserSettings";
    case "downloads" :
      return "downloads";
    case "notifications" :
      return "notifications";
    case "privacy" :
      return "privacy";
    case "tabs" :
      return "tabs";
    default:
      return;
  }
}

function getString(dict, key) {
  return Stdlib_Option.flatMap(Js_dict.get(dict, key), Js_json.decodeString);
}

function getOptString(dict, key) {
  return Stdlib_Option.flatMap(Js_dict.get(dict, key), v => {
    let match = Js_json.classify(v);
    if (typeof match !== "object" && match === "JSONNull") {
      return;
    } else {
      return Js_json.decodeString(v);
    }
  });
}

function getOptInt(dict, key) {
  return Stdlib_Option.map(Stdlib_Option.flatMap(Js_dict.get(dict, key), Js_json.decodeNumber), prim => prim | 0);
}

function getStringArray(dict, key) {
  return Stdlib_Option.getOr(Stdlib_Option.map(Stdlib_Option.flatMap(Js_dict.get(dict, key), Js_json.decodeArray), arr => Stdlib_Array.filterMap(arr, Js_json.decodeString)), []);
}

function parseFlag(json) {
  let obj = Js_json.decodeObject(json);
  if (obj === undefined) {
    return;
  }
  let match = getString(obj, "key");
  let match$1 = getString(obj, "description");
  if (match === undefined) {
    return;
  }
  if (match$1 === undefined) {
    return;
  }
  let effectsObj = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(obj, "effects"), Js_json.decodeObject), {});
  let permStrings = getStringArray(obj, "permissions");
  return {
    key: match,
    type: Stdlib_Option.getOr(Stdlib_Option.map(getString(obj, "type"), parseValueType), "boolean"),
    category: Stdlib_Option.getOr(Stdlib_Option.map(getString(obj, "category"), parseCategory), "experimental"),
    safetyLevel: Stdlib_Option.getOr(Stdlib_Option.map(getString(obj, "safetyLevel"), parseSafetyLevel), "experimental"),
    defaultValue: Stdlib_Option.getOr(Js_dict.get(obj, "defaultValue"), false),
    description: match$1,
    effects: {
      positive: getStringArray(effectsObj, "positive"),
      negative: getStringArray(effectsObj, "negative"),
      interesting: getStringArray(effectsObj, "interesting")
    },
    permissions: Stdlib_Array.filterMap(permStrings, parsePermission),
    geckoMinVersion: getOptString(obj, "geckoMinVersion"),
    geckoMaxVersion: getOptString(obj, "geckoMaxVersion"),
    documentation: getOptString(obj, "documentation"),
    bugNumber: getOptInt(obj, "bugNumber")
  };
}

function parseFlagDatabase(json) {
  let obj = Js_json.decodeObject(json);
  if (obj === undefined) {
    return {
      version: "0.0.0",
      lastUpdated: new Date(Date.now()).toISOString(),
      categories: {},
      flags: []
    };
  }
  let version = Stdlib_Option.getOr(getString(obj, "version"), "0.0.0");
  let lastUpdated = Stdlib_Option.getOr(getString(obj, "lastUpdated"), new Date(Date.now()).toISOString());
  let catsObj = Stdlib_Option.flatMap(Js_dict.get(obj, "categories"), Js_json.decodeObject);
  let categories;
  if (catsObj !== undefined) {
    let result = {};
    Object.keys(catsObj).forEach(catKey => {
      let catObj = Stdlib_Option.flatMap(Js_dict.get(catsObj, catKey), Js_json.decodeObject);
      if (catObj === undefined) {
        return;
      }
      let match = getString(catObj, "name");
      let match$1 = getString(catObj, "description");
      if (match !== undefined && match$1 !== undefined) {
        result[catKey] = {
          name: match,
          description: match$1
        };
        return;
      }
    });
    categories = result;
  } else {
    categories = {};
  }
  let flags = Stdlib_Option.getOr(Stdlib_Option.map(Stdlib_Option.flatMap(Js_dict.get(obj, "flags"), Js_json.decodeArray), arr => Stdlib_Array.filterMap(arr, parseFlag)), []);
  return {
    version: version,
    lastUpdated: lastUpdated,
    categories: categories,
    flags: flags
  };
}

function compareVersions(a, b) {
  let parseVersion = v => v.split(".").map(s => Stdlib_Option.getOr(Stdlib_Int.fromString(s, undefined), 0));
  let aParts = parseVersion(a);
  let bParts = parseVersion(b);
  let lenA = aParts.length;
  let lenB = bParts.length;
  let maxLen = lenA > lenB ? lenA : lenB;
  let _i = 0;
  while (true) {
    let i = _i;
    if (i >= maxLen) {
      return 0;
    }
    let aVal = Stdlib_Option.getOr(aParts[i], 0);
    let bVal = Stdlib_Option.getOr(bParts[i], 0);
    if (aVal < bVal) {
      return -1;
    }
    if (aVal > bVal) {
      return 1;
    }
    _i = i + 1 | 0;
    continue;
  };
}

async function checkForUpdates(currentVersion) {
  try {
    let response = await fetch("https://api.github.com/repos/hyperpolymath/fireflag/releases/latest");
    if (!response.ok) {
      return {
        TAG: "UpdateFailed",
        _0: "Failed to fetch update information"
      };
    }
    let json = await response.json();
    let latestVersion = Stdlib_Option.getOr(Stdlib_Option.flatMap(Stdlib_Option.flatMap(Js_json.decodeObject(json), obj => Js_dict.get(obj, "tag_name")), Js_json.decodeString), currentVersion);
    if (latestVersion > currentVersion) {
      return {
        TAG: "UpdateAvailable",
        _0: {
          version: latestVersion,
          lastUpdated: new Date(Date.now()).toISOString(),
          minimumGeckoVersion: "109.0",
          maximumGeckoVersion: undefined
        }
      };
    } else {
      return "UpToDate";
    }
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === "JsExn") {
      return {
        TAG: "UpdateFailed",
        _0: Stdlib_Option.getOr(Stdlib_JsExn.message(exn._1), "Unknown error")
      };
    } else {
      return {
        TAG: "UpdateFailed",
        _0: "Unknown error"
      };
    }
  }
}

async function downloadDatabase(version) {
  try {
    let url = `https://github.com/hyperpolymath/fireflag/releases/download/` + version.version + `/flags-database.json`;
    let response = await fetch(url);
    if (!response.ok) {
      return {
        TAG: "Error",
        _0: "Failed to download database"
      };
    }
    let json = await response.json();
    let db = parseFlagDatabase(json);
    return {
      TAG: "Ok",
      _0: db
    };
  } catch (raw_exn) {
    let exn = Primitive_exceptions.internalToException(raw_exn);
    if (exn.RE_EXN_ID === "JsExn") {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(Stdlib_JsExn.message(exn._1), "Download failed")
      };
    } else {
      return {
        TAG: "Error",
        _0: "Download failed"
      };
    }
  }
}

function validateFlagForBrowser(flag, browserVersion) {
  let minVer = flag.geckoMinVersion;
  let meetsMin = minVer !== undefined ? compareVersions(browserVersion, minVer) >= 0 : true;
  let maxVer = flag.geckoMaxVersion;
  let meetsMax = maxVer !== undefined ? compareVersions(browserVersion, maxVer) <= 0 : true;
  if (meetsMin) {
    return meetsMax;
  } else {
    return false;
  }
}

function filterDatabaseForBrowser(db, browserVersion) {
  return {
    version: db.version,
    lastUpdated: db.lastUpdated,
    categories: db.categories,
    flags: db.flags.filter(flag => validateFlagForBrowser(flag, browserVersion))
  };
}

function findDeprecatedFlags(db) {
  return db.flags.filter(flag => Stdlib_Option.isSome(flag.geckoMaxVersion));
}

function findUnavailableFlags(db, browserVersion) {
  return db.flags.filter(flag => !validateFlagForBrowser(flag, browserVersion));
}

async function autoUpdate(currentVersion, enableAutoUpdate) {
  if (!enableAutoUpdate) {
    return {
      TAG: "Error",
      _0: "Auto-update disabled"
    };
  }
  let status = await checkForUpdates(currentVersion);
  if (typeof status !== "object") {
    return {
      TAG: "Error",
      _0: "Already up to date"
    };
  }
  switch (status.TAG) {
    case "UpdateAvailable" :
      return await downloadDatabase(status._0);
    case "UpdateRequired" :
      return {
        TAG: "Error",
        _0: `Update required: ` + status._0
      };
    case "UpdateFailed" :
      return {
        TAG: "Error",
        _0: status._0
      };
  }
}

export {
  Fetch,
  parseSafetyLevel,
  parseValueType,
  parseCategory,
  parsePermission,
  getString,
  getOptString,
  getOptInt,
  getStringArray,
  parseFlag,
  parseFlagDatabase,
  compareVersions,
  checkForUpdates,
  downloadDatabase,
  validateFlagForBrowser,
  filterDatabaseForBrowser,
  findDeprecatedFlags,
  findUnavailableFlags,
  autoUpdate,
}
/* Stdlib_JsExn Not a pure module */
